[
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Lab 1: Seven segment display\n\n\nThe SystemVerilog implementation and simulation of a hexidecimal seven segment display on an FPGA.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Time Multiplexing Two Displays\n\n\nThe SystemVerilog implementation and simulation of a time multiplexed seven segment decoder which outputs to a 2-digit display.\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: Seven segment display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nA simple decoder was used to translate the input from a 4-throw switch into a hexadecimal output on a common-anode seven segment display.\nThe FPGA’s on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive SystemVerilog library was used to generate a clock signal at 48 MHz. A counter was then used to divide the signal down to 12 MHz, where the LED was driven according to the 25th bit to blink at 2.86 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: Seven segment display",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the E155 GitHub repository under “lab1-fpga-7-seg-display.”\n\nBlock Diagram\n Figure 1: LED and seven segment display SystemVerilog block diagram.\nThe block diagram in Figure 1 demonstrates the architecture of the entire seven segment display and LED system. The top level module, lab1_ll, includes the high speed oscillator (HSOSC), counter, LED combinational logic, and the submodule for the seven_seg_display which functions as a decoder.\n\n\nSchematic\n Figure 2: Seven segment display and LEDs circuit schematic.\nFigure 2 shows the system as arranged on the PCB (the LEDs) and the breadboard (7-segment-display). The seven segment display and each of the three onboard LEDs are current limited using a 1kΩ resister. Each segment of the display is controlled active-low by the FPGA on the PCB. Results and Discussion\n Figure 3: The lab1_ll top module functioning in simulation.\n Figure 4: Led0 blinking on after many clock ticks.\n Figure 5: The seven-seg-display module properly decoding according to its inputs.\nThe display functions in simulation. I did not write an automatic testbench; these simulation results were from manual forcing.\n Figure 6: Oscilloscope trace of the blinking LED at 2.86 Hz. The design met most of the design specifications, except that the LED blinks at 2.86 Hz, not 2.4 Hz. The other two LEDs properly turn on and off according to the input of SW6."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: Seven segment display",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was mostly successful, with some omissions mainly due to time constraints. I spent 20 hours working on this lab.\nI spent more time than I would have liked on the PCB due to missing parts, resoldering components which were misaligned, and fixing the LED solder pads which I had damaged. Radiant and its debugger were also frustrating to get working.\nDue to feeling rushed, I don’t believe that I ensured the MCU is fully functional, since when I went through the tutorial, the LEDs were behaving oddly. I did not fully diagnose this bug.\nIn the future, I will block more time in advance to finish more of future labs sooner in the week."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: Seven segment display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThis was not attempted."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 23, 2024\n\n\nJosh Brake\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Lucas Lemos is a senior undergraduate at Harvey Mudd College studying for a B.S. Engineering. He is a self-motivated engineer & student leader passionate about merging creative design and technical expertise. He has proficiency and interest in controls and electronics. Lucas has designed an embedded audio system and PCB for Motiv Electric Trucks, an analog instrumentation PCB for the HRL Labs Clinic Team, a QTP test rack for qualifying the reactor control system PCBAs for Radiant Nuclear, and is currently developing power electronics for the Exolambda Clinic team."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Time Multiplexing Two Displays",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nOne seven segment display decoder was time multiplexed to two seven segment displays. Time multiplexing is where one expensive component is used for multiple different tasks at different times, synchronized to a clock. The time multiplexing was implemented by giving the decoder the output of two 4-throw switches at different times as selected by a divided clock and a multiplexer. Additionally, which digit of the 2-digit display was enabled according to the divided clock. A nominal clock frequency of 80 Hz was chosen to eliminate visible flicker without being so high as to bleed the two digits together.\nA five LED counter counts the sum of both 4-throw switches to ensure proper switch input to the time multiplexer."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Time Multiplexing Two Displays",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for the project can be found in the E155 GitHub repository under “lab2_ll_two_displays.”\n\nBlock Diagram\n Figure 1: Block diagram of SystemVerilog modules.\nThe block diagram in Figure 1 shows the lab2_ll_two_displays top module, and the led_cnt_adder, switch_mux, seven_seg_display, clk_divider, and HSOSC submodules.\n\n\nSchematic\n Figure 2: Circuit schematic of the 2-digit display and LED counter circuit.\nFigure 2 shows the two 4-throw switches, reset button, 2-digit seven segment display, switch count LEDs, and two PNP transistors for sourcing current to the display. The display and counter LEDs are nominally current limited to 10mA using a 330Ω resister, while the PNP base current is nominally limited to 0.7mA using a 4.7kΩ resister.\n\n\nResults and Discussion\n Figure 3: The lab2_ll_two_displays top module functioning in simulation.\n Figure 4: The clock divier module properly dividing the clock according to the set divisor.\n Figure 5: The 2:1 4-bit switch mux demonstrating proper channel selection.\n Figure 6: The 4-bit LED count adder demonstrating proper addition.\nThe time multiplexed display functions in simulation. Some testbenches were fully automatic, others required visual verification since I ran out of time to fully automate them. The lab2_ll_sim doesn’t show the negated, divided clock because it was a last-minute bug-fix, but the negated clock does function in hardware."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Time Multiplexing Two Displays",
    "section": "Conclusion",
    "text": "Conclusion\nI believe this design and implementation meets the criteria for proficiency, although fails to meet certain excellence metrics. I would have fixed the last few bugs if given more time. The following bugs still present are:\n\nclk_div is (I think) 40 Hz, not 80Hz, which causes flickering.\nswitch2’s pinout to the FPGA is backwards, and the switch activates in the “off” position.\nAll of the LEDs are really dim.\nThe display changes in brightness depending on how many segments are activated.\nHuge risk of resisters shorting on the current breadboard–I need a bigger breadboard.\n\nI spent 23 hours working on this lab. The greatest time sink was redesigning my clock divider from lab 1 and writing automatic testbenches for each submodule."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2: Time Multiplexing Two Displays",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nThe two prompts were as follows: “Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.”\nand\n“Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator (inside lab1_ll) provided in the attached files.”\nThe quality of the AI output was higher than I expected, but still less than ideal. In the response to the first prompt, the AI generated a digitally controlled oscillator for dividing the clock which triggered on both the positive and negative edges of the clock, which is risky according to synchronous design. It also implemented selection using if/else in an always_comb block, which would’ve been better represented as a ternary statement to better use the multiplexer idiom. Lastly, it is not modularized and so would be difficul to test, although this could easily be fixed by prompting the AI further. Despite these flaws, the first prompt produced a fairly high quality result in seconds, and synthesized first try.\nThe response to the second prompt, which included my code from lab 1, was similarly surprisingly good despite some notable flaws. Again, the HDL code synthesized first try. The second prompt did not actually include the counter and HSOSC I provided it, and instead wrote its own inferior digitally controlled oscillator which again overly relies on if/else statements.\nThere was nothing about the code of these outputs which actually surprised me, and it ended up creating seemingly usable if slightly amateur code. The quality could likely be improved with more expert prompting. This helps me to realize that if I am to incorporate an LLM into my workflow, I shouldn’t depend on its proposed solution sine it’s likely suboptimal. I first need a clear idea of exactly what hardware to implement and loosely how, and only depend on the AI to write what I already know how to write."
  }
]